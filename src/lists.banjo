.module({
  name = "lists"
  doc = "
    Any ordered sequence of objects can be considered a list.

    Lists are easily constructed in code using list syntax: `[1,2,3]` constructs
    a three-element list with three numbers in it.

    Lists can also be constructed using concatenation; for example `[1,2] + [3,4]`
    builds a list `[1,2,3,4]`

    To append or prepend a single element to a list, put it in a singleton list and
    use concatenation; for example `[1] + [2,3]` to prepend `1` or `[1,2] + [3]` to
    append `3`.

    Recursing over a list is done like `list { nonempty(element, list without element) = ... , empty = ... }`
  "
}) @ {


  lists.nonempty = (
    doc = "Common behavior for nonempty lists.  Nonempty lists have a head and tail method that can be called if you know the list is nonempty."
  ) => {
    nonempty lists.mixin = {
      list(visitor) = visitor.nonempty(list.head, list.tail)
      list.map(f) = list.class @ {head = f(list.head), tail = list.tail.map(f)}
    }
  }

  lists.infinite = (
    doc = "
      Class for infinite lists.  Infinite lists do not support operations that require scanning the entire list,
      such a length, fold, append, and concatenation.
    "
  ) => {
    infinite lists.mixin = lists.nonempty.mixin @ {
      class = infinite lists
      list(visitor) = visitor.nonempty(list.head, list.tail)
    }
  }

  lists.empty = (
    doc = "The empty list."
  ) => lists.mixin @ .empty

  lists.singleton(element) = (
    doc = "Create a new list with a single element."
  ) => lists.mixin @ .nonempty(element, lists.empty)

  lists.unfold(generator, initial value) = (
    doc = "
      Create a new infinite list based on a generator function.  The generator takes a previous value and returns the next one.
    "
  ) => lists.infinite.mixin @ { head = initial value, tail = lists.unfold(generator, generator(initial value)) }



}