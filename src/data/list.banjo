list(variant) ↦ (
  "
    The parameter should be `.nonempty(head, tail)` for all lists except the empty list.

    Lists do implement comparisons like `==`, `<`, `≤`, `>`, `≥` and `≠`, but in order for them to work all the elements
    of the list must also implement the same comparions.
  "
) ⇒ variant @ {
  x.slice(start, end) = (
    "
      Return elements from start (inclusive) to end (exclusive).

      Negative offsets will count from the end of the list.
    "
    usage examples = [[1,2,3,4,5].slice(2,2) == [3,4]]
  ) ⇒ (
    if(start.is negative) then(x.slice(max(0, start + x.length), end)) else
    if(end.is negative) then(x.slice(start, max(0, end + x.length))) else
    x.from(start).to(end-start)
  )

  x.from(start) = (
    "
      Return a list of elements of this list after skipping some
      elements.

      If the list has fewer than `offset` elements, the resulting
      list will be empty.

      Any fractional part of the `offset` will be ignored.

      If the `offset` is equal to zero no offset will be applied.

      If the `offset` is negative, the effective offset will be the offset
      plus the length of the list, essentially allowing a negative offset
      to be used to select a specific number of the last elements of the
      list.  If `-offset` is greater than the number of elements in the list,
      the list is returned as-is.

      For example, `[1,2,3,4,5].from(2) == [3,4,5]`
    "
  ) ⇒ (
    if(start.is negative) then(x.from(max(0, start + x.length))) else
    if(start.is zero) then(x) else
    x {
      nonempty(elt, etc) = etc.from(start-1)
      empty = x
    }

  )

  x.to(limit) = (
    "
      Return a list containing elements at the start of this list up to `limit`
      elements.

      If the list already has fewer than `limit` elements, this has no effect.  A
      zero `limit` will result in an empty list.

      A negative `limit` will be added to the length of the list to calculate an effective
      `limit`, essentially requesting all but the last `-limit` elements.
    "
    usage examples = [[1,2,3,4,5].to(3) == [1,2,3]]
  ) ⇒ limit.sign {
    positive = x {
      nonempty(element, etc) = list(.nonempty(element, etc.to(limit - 1)))
      empty = x
    }
    zero = x
    negative = x.to(max(0, x.length + limit))
  }

  list.at(n) = (
    "
      Return a view of the list including only a single element after skipping `n` elements.

      If `n` is negative, the effective offset is the length of the list plus `n` - allowing a negative
      offset to work back from the end of the list.

      If `n >= list.length || -n > list.length`, an empty list is returned.
    "
    usage examples = [
      [1,2,3,4,5].at(0) == [1]
      [1,2,3,4,5].at(1) == [2]
      [1,2,3,4,5].at(-1) == [5]
      [1,2,3,4,5].at(-2) == [4]
      [1].at(3) == []
      [].at(0) == []
      [].at(-1) == []
      [1,2,3].at(-4) == []
    ]
  ) ⇒ list.range(n, 1)

  x.mapped(mapping function) = (
    "
      Create a view of the list where each elements are replaced with their corresponding
      value in the given mapping function.
    "
    usage examples = [
      [1,2,3,4,5].mapped(x -> x*x) == [1, 2*2, 3*3, 4*4, 5*5]
    ]
  ) ⇒ x {
    empty = x
    nonempty(head, tail) = list(.nonempty(mapping function(head), tail.mapped(mapping function)))
  }

  x.filtered(predicate) = (
    "
      Create a view of the list containing only elements that \"pass\" the filter.  That is,
      for any element `e`, `predicate(e) == true`.
    "
    usage examples = [[1,2,3,4].filtered(.odd) == [1,3]]
  ) ⇒ x {
    empty = x
    nonempty(head, tail) = predicate(head) {
      z.false = tail.filtered(predicate)
      z.true = list(.nonempty(head, z.false))
    }
  }

  x.right folded(function, initial state) = (
    "
      Apply the given function to each element while threading a state through
      each call.  The function accepts an object with left and right values and
      returns a new value that may either be used as a left or right value for
      the next call or returned.

      The `initial value` is used to ensure there is always a value to return
      from the fold and is effectively pre-pended to the list as part of the fold.

      This fold is right-associative and lazy, which means that only as much of the list
      that is actually used by the provided function will be walked by the algorithm.

      The final function return value is returned.  For an empty list, the `initial state` is
      returned.
    "
    usage examples = (f({left,right}) = (left + right)) ⇒ [
      [1,2,3,4,5].reverse folded(f,0) == f({left=0,right=f({left=1,right=f({left=2,right=f({left=3,right=f({left=4,right=5})})})})}) == (0+(1+(2+(3+(4+5))))) == 15
    ]
  ) ⇒ x {
    nonempty(head, tail) = function({left = initial state, right = tail.right folded(function, head)})
    empty = initial state
  }

  x.is empty = (
    "Return true if this list is empty (has no elements), otherwise return false."
    usage examples = [
      [].is empty == true
      [1].is empty == false
      [1,2,3].is empty == false
    ]
  ) ⇒ x { empty = true, nonempty() = false }

  x.is nonempty = (
    "Return true if the list has at least one element, otherwise return false."
    usage examples = [
      [1].nonempty == true
      [].nonempty == false
    ]
  ) ⇒ x { empty = false, nonempty() = true }

  x.without prefix(prefix) = (
    "If the list starts with the given prefix, return #suffix(rest of list).  Otherwise returns #not matched."
  ) ⇒ prefix {
    ; Ran out of prefix, so all the elements must have matched
    empty = .suffix(x)

    nonempty(prefix elt, prefix etc) = x {
      ; Compare this element with the corresponding prefix element
      nonempty(list elt, list etc) = (prefix elt == list elt) {
        ; Elements are equal, continue with the remaining elements (if any)
        true = list etc.without prefix(prefix etc)

        ; Elements not equal
        false = .not matched
      }

      ; Ran out of list
      empty = .not matched
    }
  }

  x.starts with(prefix) = (
    "Return true if the list is at least as long as prefix and all elements in the list are equal (using `prefix element == list element`) up to the length of the prefix"
  ) ⇒ prefix {
    ; If we reach the end of the prefix, then it was a prefix
    empty = true

    ; Still at least one more element to check in the prefix
    nonempty(prefix elt, prefix etc) = x {
      nonempty(list elt, list etc) = (prefix elt == list elt) && (list etc.starts with prefix etc)

      ; No element in the list to look at, the list is too short
      empty = false
    }
  }

  (x && result) = (
    "Return `result` if the `list` is nonempty, otherwise return `list` (which is the empty list)"
  ) ⇒ x {
    nonempty() = result
    empty = x
  }

  (x || substitute) = (
    "Return `substitute` if the `list` is empty.  Otherwise return the list itself."
  ) ⇒ x {
    nonempty() = x
    empty = substitute
  }

  (x ?: substitute) = (
    "Return `substitute` if the `list` is empty.  Otherwise return the first element."
  ) ⇒ x {
    nonempty(first) = first
    empty = substitute
  }

  x.flattened = (
    "
      Assuming the list contains only lists, return a view that is the concatenation or chaining of all those lists.

      Note that this is roughly equivalent to `list.sum([])`.
    "
    usage examples = [
      [[1,2],[3,4],[5,6]].flattened == [1,2,3,4,5,6]
    ]
  ) ⇒ x {
    empty = x
    nonempty(elt, etc) = elt + etc.flattened
  }

  list.sum(start) = (
    "
      Return the result of a `+` operation on all elements of the list and the `start` parameter (typically
      `0` or `[]` is used as the `start` value)
    "
    usage examples = [
      [1,2,3].sum(0) == 0 + 1 + 2 + 3 == 6
      [[1,2],[3,4],[5,6]].sum([]) == [] + [1,2] + [3,4] + [5,6] == [1,2,3,4,5,6]
    ]
  ) ⇒ list.left folded(
    {left, right} -> left + right
    start
  )


  list.with offsets = (
    "
      Return a view of the list where the list and its tails have an extra method `offset` returning the number of
      elements passed to reach that tail.
    "

    list with offsets(offset list, start offset) = list.class.mixin @ (
      (visitor) -> offset list({
        empty = offset list
        nonempty(element, etc) = list(.nonempty(element, list with offsets(etc, start offset+1)))
      })) @ {
      offset = start offset
      x.to(n) = list with offsets(x:to(n), start offset)
      x.mapped(mapping) = list with offsets(x:map(mapping), start offset)
    }
  ) ⇒ list with offsets(list, 0)

  list.left folded(function, initial state) = (
    "
      Apply the given function to each element while threading a state through
      each call.  The function accepts an element and a state and returns a new
      state.

      The `initial value` is used to ensure there is always a value to return
      from the fold and is effectively pre-pended to the list as part of the fold.

      This fold is left-associative.

      The final function value is returned.  For an empty list, the `initial state` is
      returned.
    "
    usage examples = (f({left,right}) = (left + right)) ⇒ [
      [1,2,3,4,5].folded(f,0) == 15
      [1,2,3,4,5].folded(f,0) == f({left=f({left=f({left=f({left=f({left=0,right=1}),right=2}),right=3}),right=4}),right=5})
    ]

    helper(tail, p) = tail({
      nonempty(element, tail tail) = helper(tail tail, {left = function(p @ {right=element})})
      empty = p.left
    })
  ) ⇒ helper(list, {left = initial state})

  list.length = (
    "
      Calculate the length of the list.

      For example: `[1,2,3].length == 3`
    "
  ) ⇒ list.left folded({right} -> 1 + right, 0)

  (x ∈ y) = (
    "Return true if `x == element` for any `element` in `list`."
    usage examples = [
       "apple" ∈ ["apple", "pear", "banana"] == true
       "orange" ∈ ["apple", "pear", "banana"] == true
    ]
  ) ⇒ y {
    empty = false
    nonempty(elt, tail) = (x == elt) || (x ∈ tail)
  }


  (x + y) = (
    "
      Return a list with all the elements of this list followed by all the elements of the other list.

      If the suffix is an infinite list, the result will also be an infinite list.
    "
  ) ⇒ x {
    empty = y
    nonempty(elt, tail) = [elt] + (tail + y)
  }


  list.repeating = (
    "Return a cyclic view of this list.  The resulting list repeats the elements from this list endlessly."
  ) ⇒ list { empty = list, nonempty(elt, etc) = list(.nonempty(elt, etc.repeating)) }

  (x == y) = (
    "
      True if the lists are the same length and each element
      of both lists is `==` the element at the same position
      in the other list.
    "
    usage examples = [
      [] == []
      [1, 2] == [1, 2]
      ([1,2,3] == []) == false
    ]
  ) ⇒ x {
    empty = y.is empty
    nonempty(x head, x tail) = y {
      empty = false
      nonempty(y head, y tail) =
        (x head == y head) &&
        (x tail == y tail)
    }
  }

  x.strip common prefix(y) =  (
    "
      Identify and a remove a common prefix from the two lists; the result is
      returned as a two-tuple.
    "
  ) ⇒ x {
    empty = .(x, y)
    nonempty(x head, x tail) = y {
      empty = .(x, y)
      nonempty(y head, y tail) = (x head == y head) {
        true = x tail.strip common prefix(y tail)
        false = .(x, y)
      }
    }
  }

  (x < y) = (
    "
      True if the first list is less than the second.

      1. If the first list is a prefix of the second, return true
      2. If the second list is prefix of the first, or the lists are equal, return false
      3. The element after any common prefix is compared using `<`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) -> xx {
      empty = ! yy.is empty ; Empty list is less than any list but the empty list
      nonempty(x elt) = yy {
        empty = false ; We cannot be less than the empty list
        nonempty(y elt) = x elt < y elt
      }
  })

  (x > y) = (
    "
      True if the first list is greater than the second.

      1. If the first list is a prefix of the second, or the lists are equal, return false
      2. If the second list is prefix of the first, return true
      3. The element after any common prefix is compared using `>`, and the result is returned
    "
  ) => x.strip common prefix(y) ((xx, yy) -> xx {
      empty = false ; Empty list is not greater than any other list
      nonempty(x elt) = yy {
        empty = true ; Nonempty list is always greater than an empty list
        nonempty(y elt) = x elt > y elt
      }
  })

  (x ≤ y) = (
    "
      True if the first list is less than or equal the second.

      1. If the first list is a prefix of the second, or the lists are equal, return true.  Uses `==` to compare.
      2. If the second list is prefix of the first, return false
      3. The element after any common prefix is compared using `<`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) ↦ xx {
      empty = true ; Empty list is less than or equal to all lists
      nonempty(x elt) = yy {
        empty = false ; We cannot be less than the empty list if we are not empty
        nonempty(y elt) = x elt < y elt ; Only have to check <, we already checked ==
      }
  })

  (x ≥ y) = (
    "
      True if the first list is less than or equal the second.

      1. If the first list is a prefix of the second, false.
      2. If the second list is prefix of the first, or the lists are equal, true
      3. The element after any common prefix is compared using `>`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) ↦ xx {
      empty = yy.is empty ; [] is only ≥ []
      nonempty(x elt) = yy {
        empty = true ; All lists are ≥ []
        nonempty(y elt) = x elt > y elt ; Only have to check >, we already checked ==
      }
  })
}