{
  list.empty = (
    "The empty list"
  ) ⇒ list(.empty) @ { label = "[]" }

  list.element(elt) = "A list of a single element" ⇒ list.node(elt, list.empty)
  
  list.node(first, tail) = (
    "Create a list by prepending a single element to another list"
  ) ⇒ list(.node(first, tail))

  list.generator(first, f) = (
    "Create a list using an initial element and a function that takes an element and returns the next one"
  ) ⇒ list.node(first, list.generator(f(first), f)) @ {
    label = "list.generator(" + first + ", " + f + ")"
  }

  label = "data.list"

} @ list(variant) ↦ (
  "
  The parameter should be `.node(head, tail)` for all lists except the empty list, which
  uses `.empty`.

  Lists do implement comparisons like `==`, `<`, `≤`, `>`, `≥` and `≠`, but in order for them to work all the elements
  of the list must also implement the same comparisons.
  "
) ⇒ (a(locs) ↦ locs ; a.at) @ traits.collection(list.{empty, element}) @ {
  if = "
    Examination: `.node(first, tail)` for a non-empty list, `.empty` otherwise.
  " ⇒ variant

  a.into(algebra) = "
    Apply the given collection algebra to this list.  Each element of the list
    is wrapped using `algebra.element` and the resulting values are summed together with
    `algebra.empty`.
    
    For example:
    
    `[1,2].into(a) == a.element(1) + (a.element(2) + a.empty)`
    `[].into(a) == a.empty`
    
    This can be used to do a right fold over the list.
  " ⇒ a.if {
    empty = algebra.empty    
    node(first, tail) = algebra.element(first) + tail.into(algebra)
  }

  
  a.slice(start, end) = "
      A 'slice' of the list elements from start (inclusive) to end (exclusive).

      Negative offsets will count from the end of the list.
  " ⇒ (
    usage examples = [
      [1,2,3,4,5].slice(2,4) == [3,4]
      [1,2,3,4,5].slice(2,2) == []
      [1,2,3,4,5].slice(2,-1) == [3, 4]
    ]
  ) ⇒ (
    if(start.is negative) then(a.slice(max(0, start + a.length), end)) else
    if(end.is negative) then(a.slice(start, max(0, end + a.length))) else
    a.from(start).to(end-start)
  )

  
  x.from(start) = "
      Return a list of elements of this list after skipping some
      elements.

      If the list has fewer than `offset` elements, the resulting
      list will be empty.

      Any fractional part of the `offset` will be ignored.

      If the `offset` is equal to zero no offset will be applied.

      If the `offset` is negative, the effective offset will be the offset
      plus the length of the list, essentially allowing a negative offset
      to be used to select a specific number of the last elements of the
      list.  If `-offset` is greater than the number of elements in the list,
      the list is returned as-is.

      For example, `[1,2,3,4,5].from(2) == [3,4,5]`
  " ⇒ (
    usage examples = [
      [1,2,3].from(0) == [1,2,3]
      [true,false,true].from(-1) == [true]
      [false,false,true].from(1) == [false, true]
      [3].from(-4) == [3]
    ]
  ) ⇒ (
    if(start < 0) then(x.from(max(0, start + x.length))) else
    if(start == 0) then(x) else
    x.if {
      node(elt, etc) = etc.from(start-1)
      empty = x
    }
  )

  a.to(limit) = (
    "
      Return a list containing elements at the start of this list up to `limit`
      elements.

      If the list already has fewer than `limit` elements, this has no effect.  A
      zero `limit` will result in an empty list.

      A negative `limit` will be added to the length of the list to calculate an effective
      `limit`, essentially requesting all but the last `-limit` elements.
    "
    usage examples = [[1,2,3,4,5].to(3) == [1,2,3]]
  ) ⇒ limit.sign.if {
    positive = a.if {
      node(element, etc) = list.node(element, etc.to(limit - 1))
      empty = a
    }
    zero = []
    negative = a.to(max(0, a.length + limit))
    undefined = []
  }

  x.at(n) = (
    "
    Return a view of the list including only a single element after skipping `n` elements.

    If `n` is negative, the effective offset is the length of the list plus `n` - allowing a negative
    offset to work back from the end of the list.

    If `n >= list.length` or `-n > list.length`, an empty list is returned.
    "
    usage examples = [
      [1,2,3,4,5].at(0) == [1]
      [1,2,3,4,5].at(1) == [2]
      [1,2,3,4,5].at(-1) == [5]
      [1,2,3,4,5].at(-2) == [4]
      [1].at(3) == []
      [].at(0) == []
      [].at(-1) == []
      [1].at(-1) == [1]
      [1].at(-2) == []
      [1,2,3].at(-4) == []
    ]
  ) ⇒ (
    if(n < 0) then (
      (nn = n + x.length) ⇒
      if(nn >= 0) then (x.at(max(0, n + x.length))) else []
    ) else (
      x.from(n).first
    )
  )

  x.first = (
    "A list containing only the first element of `list`, or an empty list if `list` is empty."
  ) ⇒ x.if {
    node(n, tail) = [n]
    empty = []
  }
  
  x.last = (
    "A list containing only the last element of `list`, or an empty list if `list` is empty."
  ) ⇒ x.if {
    node(element, tail) = tail.if { 
      empty = [element]
      node(_, _) = tail.last
    }
    empty = []
  }

  x.zipped with(y) = (
    "Create a list of matching pairs, one from each list.  The list will contain as many
     elements as the shorter of the two lists."
  ) ⇒ x.if {
    empty = x
    node(x head, x tail) = y.if {
      empty = y
      node(y head, y tail) = list.node(
        .(x head, y head),
        x tail.zipped with(y tail)
      )
    }
  }

  x.without prefix(prefix) = (
    "If the list starts with the given prefix, return `.suffix(rest of list)`.  Otherwise returns `.not matched`."
  ) ⇒ prefix.if {
    # Ran out of prefix, so all the elements must have matched
    empty = .suffix(x)

    node(prefix elt, prefix etc) = x.if {
      # Compare this element with the corresponding prefix element
      node(list elt, list etc) = (prefix elt == list elt).if {
        # Elements are equal, continue with the remaining elements (if any)
        true = list etc.without prefix(prefix etc)

        # Elements not equal
        false = .not matched
      }

      # Ran out of list
      empty = .not matched
    }
  }

  x.starts with(prefix) = (
    "Return true if the list is at least as long as prefix and all elements in the list are equal (using `prefix element == list element`) up to the length of the prefix"
  ) ⇒ prefix.if {
    # If we reach the end of the prefix, then it was a prefix
    empty = true

    # Still at least one more element to check in the prefix
    node(prefix elt, prefix etc) = x.if {
      node(list elt, list etc) = (prefix elt == list elt) && (list etc.starts with(prefix etc))

      # No element in the list to look at, the list is too short
      empty = false
    }
  }

  (x && result) = (
    "Return `result` if the `x.is nonempty`, otherwise return `x` (which is the empty list)"
  ) ⇒ x.if {
    node() = result
    empty = x
  }

  (x || substitute) = (
    "Return `substitute` if `x.is empty`.  Otherwise return `x`."
  ) ⇒ x.if {
    node() = x
    empty = substitute
  }

  (x ?: substitute) = (
    "Return `substitute` if `x` is empty.  Otherwise return the first element in `x`."
  ) ⇒ x.if {
    node(first) = first
    empty = substitute
  }

  x.with offsets from(offset) = (
    "
    A list of each `element` from `list` wrapped in an object `{ element, offset }` where the offset is 
    the number of previous elements in the list, plus the offset given.
    "     
  ) ⇒ x.if {
    empty = x
    node(element, tail) = list.node({element, offset}, tail.with offsets from(offset+1))
  }
  
  x.with offsets = (
    "
    A list of each `element` in `list` with an object `{ element, offset }`, where `offset` is the 
    number of previous elements in the list
    "
  ) ⇒ x.with offsets from(x, 0)

  x.length = x.size

  (x ∈ y) = (
    "Return true if `x == element` for any `element` in `list`."
    usage examples = [
       "apple" ∈ ["apple", "pear", "banana"]
       ¬("orange" ∈ ["apple", "pear", "banana"])
    ]
  ) ⇒ y.if {
    empty = false
    node(elt, tail) = (x == elt) || (x ∈ tail)
  }

  (x + y) = (
    "
      Return a list with all the elements of this list followed by all the elements of the other list.

      If the suffix is an infinite list, the result will also be an infinite list.
    "
  ) ⇒ x.if {
    empty = y
    node(elt, tail) = list.node(elt, tail + y)
  }

  list.repeating = (
    "Return a cyclic view of this list.  The resulting list repeats the elements from this list endlessly."
  ) ⇒ list { empty = list, node(elt, etc) = list.node(elt, etc.repeating) }

  (x == y) = (
    "
      True if the lists are the same length and each element
      of both lists is `==` the element at the same position
      in the other list.
    "
    usage examples = [
      [] == []
      [1, 2] == [1, 2]
      ([1,2,3] == []) == false
    ]
  ) ⇒ x.if {
    empty = y.is empty
    node(x head, x tail) = y.if {
      empty = false
      node(y head, y tail) =
        (x head == y head) &&
        (x tail == y tail)
    }
  }

  (x != y) = (
    "True if the lists are not equal# either they have a different number
     of elements or there are pairs of elements at the same position which
     return true for `a != b`"
  ) ⇒ x.if {
    empty = ! y.is empty
    node(x head, x tail) = y.if {
      empty = true
      node(y head, y tail) =
        (x head != y head) ||
        (x tail != y tail)
    }
  }

  x.strip common prefix(y) =  (
    "
      Identify and a remove a common prefix from the two lists# the result is
      returned as a two-tuple.
    "
  ) ⇒ x.if {
    empty = .(x, y)
    node(x head, x tail) = y.if {
      empty = .(x, y)
      node(y head, y tail) = (x head == y head) {
        true = x tail.strip common prefix(y tail)
        false = .(x, y)
      }
    }
  }

  (x < y) = (
    "
      True if the first list is less than the second.

      1. If the first list is a prefix of the second, return true
      2. If the second list is prefix of the first, or the lists are equal, return false
      3. The element after any common prefix is compared using `<`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) -> xx.if {
      empty = ! yy.is empty # Empty list is less than any list but the empty list
      node(x elt) = yy.if {
        empty = false # We cannot be less than the empty list
        node(y elt) = x elt < y elt
      }
  })

  (x > y) = (
    "
      True if the first list is greater than the second.

      1. If the first list is a prefix of the second, or the lists are equal, return false
      2. If the second list is prefix of the first, return true
      3. The element after any common prefix is compared using `>`, and the result is returned
    "
  ) => x.strip common prefix(y) ((xx, yy) -> xx.if {
      empty = false # Empty list is not greater than any other list
      node(x elt) = yy.if {
        empty = true # Nonempty list is always greater than an empty list
        node(y elt) = x elt > y elt
      }
  })

  (x ≤ y) = (
    "
      True if the first list is less than or equal to the second.

      1. If the first list is a prefix of the second, or the lists are equal, return true.  Uses `==` to compare.
      2. If the second list is prefix of the first, return false
      3. The element after any common prefix is compared using `<`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) ↦ xx.if {
      empty = true # Empty list is less than or equal to all lists
      node(x elt) = yy.if {
        empty = false # We cannot be less than the empty list if we are not empty
        node(y elt) = x elt < y elt # Only have to check <, we already checked ==
      }
  })

  (x ≥ y) = (
    "
      True if the first list is less than or equal to the second.

      1. If the first list is a prefix of the second, false.
      2. If the second list is prefix of the first, or the lists are equal, true
      3. The element after any common prefix is compared using `>`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) ↦ xx.if {
      empty = yy.is empty # [] is only ≥ []
      node(x elt) = yy.if {
        empty = true # All non empty lists are ≥ []
        node(y elt) = x elt > y elt # Only have to check >, we already checked ==
      }
  })

  x.group by(_ eq) = (
    "Equals a list of lists where all elements of each list have `(eltM) eq (eltN)`.  `_ eq` must be associative and commutative." 
    
    examples = [
      [1,2,3,4,5].group by(x ↦ y ↦ x.is even == y.is even) == [[1,3,5],[2,4]]
    ]
    
  ) ⇒ x.if {
    node(elt, tail) = list.node(
      list.node(elt, tail.selection((x) eq)) # Build grouped list
      tail.selection(not ∘ (x) eq).group by(_ eq) # Eliminate already grouped values from the tail and group 
    )
    empty = list.empty
  }
  
  x.label = (["["] + (x.at(0) ; .label) + (x.from(1) ; (s -> ", " + s.label)) + ["]"]).sum("")
  
  
}