{
  list.empty = (
    "The empty list"
  ) ⇒ list(.empty) @ { label = "[]" }

  list.node(first, tail) = (
    "Create a list by prepending a single element to another list"
  ) ⇒ list(.node(first, tail))

  list.generator(first, f) = (
    "Create a list using an initial element and a function that takes an element and returns the next one"
  ) ⇒ list.node(first, list.generator(f(first), f)) @ {
    label = "list.generator(" + first + ", " + f + ")"
  }

  label = "data.list"

} @ list(variant) ↦ (
  "
    The parameter should be `.node(head, tail)` for all lists except the empty list, which
    uses `.empty`.

    Lists do implement comparisons like `==`, `<`, `≤`, `>`, `≥` and `≠`, but in order for them to work all the elements
    of the list must also implement the same comparisons.
  "
) ⇒ {
  if = (
    "
    Examination: `.node(first, tail)` for a non-empty list, `.empty` otherwise.
    "
  ) ⇒ variant

  into(algebra) = (
    "
    Process/transform the list.
    
    Equals `algebra.node(algebra.element(first), algebra.tail(tail))` for a non-empty 
    list, `algebra.empty` otherwise.
    
    Default implementations are provided to the algebra that if left unchanged simply result in a list again: 
    `{ node = data.list.node, element = identity function, tail = .into(algebra), empty = data.list.empty }`
    
    This can be passed a \"fold\" or \"catamorphism\" to process the list and return an aggregate
    or another data structure altogether.
    
    From another perspective, this treats the list as a suspension of its constructors and essentially redirects 
    the constructors `list.{node,empty}` to use the given algebra for re-construction instead.  
    "
    
    default algebra = list.{node,empty} @ { element = identity function, algebra.tail = .into(algebra) }
    a = default algebra @ algebra
  ) ⇒ variant {
    empty = a.empty
    node(first, tail) = a.node(a.element(first), a.tail(tail))
  }
  
  (a *> f) = (
    "A list mapped by the function `f`.  That is, a list of `f(element)` for each `element ∈ a`." 
  ) ⇒ a.into { element = f }
  
  a.slice(start, end) = (
    "
      A 'slice' of the list elements from start (inclusive) to end (exclusive).

      Negative offsets will count from the end of the list.
    "
    usage examples = [
      [1,2,3,4,5].slice(2,4) == [3,4]
      [1,2,3,4,5].slice(2,2) == []
      [1,2,3,4,5].slice(2,-1) == [3, 4]
    ]
  ) ⇒ (
    if(start.is negative) then(a.slice(max(0, start + a.length), end)) else
    if(end.is negative) then(a.slice(start, max(0, end + a.length))) else
    a.from(start).to(end-start)
  )

  x.from(start) = (
    "
      Return a list of elements of this list after skipping some
      elements.

      If the list has fewer than `offset` elements, the resulting
      list will be empty.

      Any fractional part of the `offset` will be ignored.

      If the `offset` is equal to zero no offset will be applied.

      If the `offset` is negative, the effective offset will be the offset
      plus the length of the list, essentially allowing a negative offset
      to be used to select a specific number of the last elements of the
      list.  If `-offset` is greater than the number of elements in the list,
      the list is returned as-is.

      For example, `[1,2,3,4,5].from(2) == [3,4,5]`
    "
  ) ⇒ (
    if(start.is negative) then(x.from(max(0, start + x.length))) else
    if(start.is zero) then(x) else
    x.if {
      node(elt, etc) = etc.from(start-1)
      empty = x
    }

  )

  a.to(limit) = (
    "
      Return a list containing elements at the start of this list up to `limit`
      elements.

      If the list already has fewer than `limit` elements, this has no effect.  A
      zero `limit` will result in an empty list.

      A negative `limit` will be added to the length of the list to calculate an effective
      `limit`, essentially requesting all but the last `-limit` elements.
    "
    usage examples = [[1,2,3,4,5].to(3) == [1,2,3]]
  ) ⇒ limit.sign.if {
    positive = a.if {
      node(element, etc) = list.node(element, etc.to(limit - 1))
      empty = a
    }
    zero = []
    negative = a.to(max(0, a.length + limit))
    undefined = []
  }

  list.at(n) = (
    "
      Return a view of the list including only a single element after skipping `n` elements.

      If `n` is negative, the effective offset is the length of the list plus `n` - allowing a negative
      offset to work back from the end of the list.

      If `n >= list.length || -n > list.length`, an empty list is returned.
    "
    usage examples = [
      [1,2,3,4,5].at(0) == [1]
      [1,2,3,4,5].at(1) == [2]
      [1,2,3,4,5].at(-1) == [5]
      [1,2,3,4,5].at(-2) == [4]
      [1].at(3) == []
      [].at(0) == []
      [].at(-1) == []
      [1,2,3].at(-4) == []
    ]
  ) ⇒ list.range(n, 1)

  list.first = (
    "A list containing only the first element of `list`, or an empty list if `list` is empty."
  ) ⇒ list.at(0)
  
  list.last = (
    "A list containing only the last element of `list`, or an empty list if `list` is empty."
  ) ⇒ list.at(-1)

  x.where(predicate) = (
    "Create a view of the list containing only elements that \"pass\" the filter.  That is,
     for any element `e`, `predicate(e) == true`."
    usage examples = [[1,2,3,4].where(.is odd) == [1,3]]
  ) ⇒ x.into {
    empty = list.empty
    node(first, tail) = predicate(first).if {
      false = tail
      true = list.node(first, tail)
    }
  }
  
  x.unless(predicate) = (
    "Equals a view of the list containing only elements that \"fail\" the filter.  That is,
     for any element `e`, `predicate(e) == false`."
  ) ⇒ x.where(not ∘ predicate)

  x.zipped with(y) = (
    "Create a list of matching pairs, one from each list.  The list will contain as many
     elements as the shorter of the two lists."
  ) ⇒ x.if {
    empty = x
    node(x head, x tail) = y.if {
      empty = y
      node(y head, y tail) = list.node(
        .(x head, y head),
        x tail.zipped with(y tail)
      )
    }
  }

  x.none(predicate) = (
    "Return true if there are no elements in the list for which `predicate(element) == true`"

    usage examples = [
      [1,-2,3,-4].none(.is positive) == false
      [1,-2,3,-4].none(.is not a number) == true
    ]
  ) ⇒ x.where(predicate).is empty

  x.any(predicate) = (
    "Return true if there is at least one element in the list for which `predicate(element) == true`"
    
  ) ⇒ ! x.none(predicate)
  
  x.all(predicate) = (
    "Return true if there are no elements in the list for which `predicate(element) == false`"

    usage examples = [
        [1,2,3,4].all(.is positive) == true
        [-1,-2,-3].all(.is negative) == true
        [1, -2, 3].all(.is positive) == false
    ]
  ) ⇒ x.none(elt -> ! predicate(elt))

  x.is empty = (
    "true iff this list is empty (has no elements), otherwise false"
    usage examples = [
      [].is empty == true
      [1].is empty == false
      [1,2,3].is empty == false
    ]
  ) ⇒ x.if { empty = true, node() = false }

  x.is nonempty = (
    "true iff the list has at least one element, otherwise false"
    usage examples = [
      [1].nonempty == true
      [].nonempty == false
    ]
  ) ⇒ x.if { empty = false, node() = true }

  x.without prefix(prefix) = (
    "If the list starts with the given prefix, return `.suffix(rest of list)`.  Otherwise returns `.not matched`."
  ) ⇒ prefix.if {
    # Ran out of prefix, so all the elements must have matched
    empty = .suffix(x)

    node(prefix elt, prefix etc) = x.if {
      # Compare this element with the corresponding prefix element
      node(list elt, list etc) = (prefix elt == list elt).if {
        # Elements are equal, continue with the remaining elements (if any)
        true = list etc.without prefix(prefix etc)

        # Elements not equal
        false = .not matched
      }

      # Ran out of list
      empty = .not matched
    }
  }

  x.starts with(prefix) = (
    "Return true if the list is at least as long as prefix and all elements in the list are equal (using `prefix element == list element`) up to the length of the prefix"
  ) ⇒ prefix.if {
    # If we reach the end of the prefix, then it was a prefix
    empty = true

    # Still at least one more element to check in the prefix
    node(prefix elt, prefix etc) = x.if {
      node(list elt, list etc) = (prefix elt == list elt) && (list etc.starts with prefix etc)

      # No element in the list to look at, the list is too short
      empty = false
    }
  }

  (x && result) = (
    "Return `result` if the `x.is nonempty`, otherwise return `x` (which is the empty list)"
  ) ⇒ x.if {
    node() = result
    empty = x
  }

  (x || substitute) = (
    "Return `substitute` if `x.is empty`.  Otherwise return `x`."
  ) ⇒ x.if {
    node() = x
    empty = substitute
  }

  (x ?: substitute) = (
    "Return `substitute` if `x` is empty.  Otherwise return the first element in `x`."
  ) ⇒ x.if {
    node(first) = first
    empty = substitute
  }

  list.sum(start) = (
    "
      Return the result of a `+` operation on all elements of the list and the `start` parameter (typically
      `0`, `[]`, or another appropriate identity for `+` is used as the `start` value)
      
      The list must be a finite list.
    "
    usage examples = [
      [1,2,3].sum(0) == 0 + 1 + 2 + 3 == 6
      [[1,2],[3,4],[5,6]].sum([]) == [] + [1,2] + [3,4] + [5,6] == [1,2,3,4,5,6]
    ]
  ) ⇒ list.into {
    empty = start
    node(elt, sum) = elt + sum
  }

  x.flattened = (
    "Assuming the list contains only lists, return a view that is the concatenation or chaining of all those lists."
    usage examples = [
      [[1,2],[3,4],[5,6]].flattened == [1,2,3,4,5,6]
    ]
  ) ⇒ list.sum(list.empty)

  list.with offsets from(offset) = (
    "
    A list of each `element` from `list` wrapped in an object `{ element, offset }` where the offset is 
    the number of previous elements in the list, plus the offset given.
    "     
  ) ⇒ list.if {
    empty = list.empty
    node(element, tail) = list.node({element, offset}, tail.with offsets from(offset+1))
  }
  
  list.with offsets = (
    "
    A list of each `element` in `list` with an object `{ element, offset }`, where `offset` is the 
    number of previous elements in the list
    "
  ) ⇒ list.with offsets from(list, 0)

  list.length = (
    "
      Calculate the length of the list.

      For example: `[1,2,3].length == 3`
    "
    usage examples = [
      [1,2,3].length == 3
      [].length == 0
    ]
  ) ⇒ list.into {
    node(elt, tail) = 1 + tail
    empty = 0
  }
    

  (x ∈ y) = (
    "Return true if `x == element` for any `element` in `list`."
    usage examples = [
       "apple" ∈ ["apple", "pear", "banana"] == true
       "orange" ∈ ["apple", "pear", "banana"] == true
    ]
  ) ⇒ y.if {
    empty = false
    node(elt, tail) = (x == elt) || (x ∈ tail)
  }


  (x + y) = (
    "
      Return a list with all the elements of this list followed by all the elements of the other list.

      If the suffix is an infinite list, the result will also be an infinite list.
    "
  ) ⇒ x.if {
    empty = y
    node(elt, tail) = list.node(elt, tail + y)
  }


  list.repeating = (
    "Return a cyclic view of this list.  The resulting list repeats the elements from this list endlessly."
  ) ⇒ list { empty = list, node(elt, etc) = list.node(elt, etc.repeating) }

  (x == y) = (
    "
      True if the lists are the same length and each element
      of both lists is `==` the element at the same position
      in the other list.
    "
    usage examples = [
      [] == []
      [1, 2] == [1, 2]
      ([1,2,3] == []) == false
    ]
  ) ⇒ x.if {
    empty = y.is empty
    node(x head, x tail) = y.if {
      empty = false
      node(y head, y tail) =
        (x head == y head) &&
        (x tail == y tail)
    }
  }

  (x != y) = (
    "True if the lists are not equal# either they have a different number
     of elements or there are pairs of elements at the same position which
     return true for `a != b`"
  ) ⇒ x.if {
    empty = ! y.is empty
    node(x head, x tail) = y.if {
      empty = true
      node(y head, y tail) =
        (x head != y head) ||
        (x tail != y tail)
    }
  }

  x.strip common prefix(y) =  (
    "
      Identify and a remove a common prefix from the two lists# the result is
      returned as a two-tuple.
    "
  ) ⇒ x.if {
    empty = .(x, y)
    node(x head, x tail) = y.if {
      empty = .(x, y)
      node(y head, y tail) = (x head == y head) {
        true = x tail.strip common prefix(y tail)
        false = .(x, y)
      }
    }
  }

  (x < y) = (
    "
      True if the first list is less than the second.

      1. If the first list is a prefix of the second, return true
      2. If the second list is prefix of the first, or the lists are equal, return false
      3. The element after any common prefix is compared using `<`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) -> xx.if {
      empty = ! yy.is empty # Empty list is less than any list but the empty list
      node(x elt) = yy.if {
        empty = false # We cannot be less than the empty list
        node(y elt) = x elt < y elt
      }
  })

  (x > y) = (
    "
      True if the first list is greater than the second.

      1. If the first list is a prefix of the second, or the lists are equal, return false
      2. If the second list is prefix of the first, return true
      3. The element after any common prefix is compared using `>`, and the result is returned
    "
  ) => x.strip common prefix(y) ((xx, yy) -> xx.if {
      empty = false # Empty list is not greater than any other list
      node(x elt) = yy.if {
        empty = true # Nonempty list is always greater than an empty list
        node(y elt) = x elt > y elt
      }
  })

  (x ≤ y) = (
    "
      True if the first list is less than or equal to the second.

      1. If the first list is a prefix of the second, or the lists are equal, return true.  Uses `==` to compare.
      2. If the second list is prefix of the first, return false
      3. The element after any common prefix is compared using `<`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) ↦ xx.if {
      empty = true # Empty list is less than or equal to all lists
      node(x elt) = yy.if {
        empty = false # We cannot be less than the empty list if we are not empty
        node(y elt) = x elt < y elt # Only have to check <, we already checked ==
      }
  })

  (x ≥ y) = (
    "
      True if the first list is less than or equal to the second.

      1. If the first list is a prefix of the second, false.
      2. If the second list is prefix of the first, or the lists are equal, true
      3. The element after any common prefix is compared using `>`, and the result is returned.
    "
  ) ⇒ x.strip common prefix(y) ((xx, yy) ↦ xx.if {
      empty = yy.is empty # [] is only ≥ []
      node(x elt) = yy.if {
        empty = true # All non empty lists are ≥ []
        node(y elt) = x elt > y elt # Only have to check >, we already checked ==
      }
  })

  x.group by(_ eq) = (
    "Equals a list of lists where all elements of each list have `(eltM) eq (eltN)`.  `_ eq` must be associative and commutative." 
    
    examples = [
      [1,2,3,4,5].group by(x ↦ y ↦ x.is even == y.is even) == [[1,3,5],[2,4]]
    ]
    
  ) ⇒ x.if {
    node(elt, tail) = list.node(
      list.node(elt, tail.where((x) eq)) # Build grouped list
      tail.unless((x) eq).group by(_ eq) # Eliminate already grouped values from the tail and group 
    )
    empty = list.empty
  }
  
  x.label = x*.label.if { 
    empty = "[]"
    node(first, rest) = "[" + first + (rest *> ", ".+).sum("]")
  } 
  
  
}